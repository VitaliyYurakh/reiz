import { promises as fs } from "node:fs";
import path from "node:path";
import fg from "fast-glob";
import { optimize } from "svgo";
import { load } from "cheerio";

const CWD = process.cwd();
const IN_DIR = path.join(CWD, "public", "img", "icons");
const OUT_DIR = path.join(CWD, "public", "img", "sprite");
const OUT_FILE = path.join(OUT_DIR, "sprite.svg");

const isSvg = (s) => /\.svg$/i.test(s);

const svgoCfg = (prefix) => ({
  multipass: true,
  plugins: [
    {
      name: "preset-default",
      params: {
        overrides: {
          removeViewBox: false,
          moveElemsAttrsToGroup: false,
          moveGroupAttrsToElems: false,
          removeHiddenElems: false,
          removeUselessDefs: false,
          collapseGroups: false,
          convertShapeToPath: false,
        },
      },
    },
    { name: "removeDimensions", active: true },
    { name: "prefixIds", params: { prefix } },
  ],
});

function fileIdFromRel(rel) {
  // icons/social/inst.svg -> social-inst
  return rel
    .replace(/\\/g, "/")
    .replace(/^.*?icons\//, "")
    .replace(/\.svg$/i, "")
    .replace(/\//g, "-")
    .toLowerCase();
}

function hasGraphics($node) {
  return (
    $node.find("path,g,rect,circle,ellipse,polygon,polyline,line,use").length >
    0
  );
}

async function build() {
  const relList = await fg("**/*.svg", { cwd: IN_DIR, dot: false });
  if (!relList.length) {
    console.error(`[sprite] Нет SVG в ${path.relative(CWD, IN_DIR)}`);
    process.exit(2);
  }

  const symbols = [];
  const sharedDefs = new Set();

  for (const rel of relList) {
    const abs = path.join(IN_DIR, rel);
    if (!isSvg(abs)) continue;

    const id = fileIdFromRel(rel);
    const raw = await fs.readFile(abs, "utf8");

    const { data: optim } = optimize(raw, svgoCfg(`${id}-`));

    const $ = load(optim, { xmlMode: true });
    const $svg = $("svg").first();
    if (!$svg.length) {
      console.warn(`[sprite] Пропущено (нет <svg>): ${rel}`);
      continue;
    }

    const viewBox =
      $svg.attr("viewBox") ||
      (function fallback() {
        const w = $svg.attr("width");
        const h = $svg.attr("height");
        return w && h ? `0 0 ${parseFloat(w)} ${parseFloat(h)}` : null;
      })();

    $svg.find("defs").each((_, el) => {
      const html = $(el).html()?.trim();
      if (html) sharedDefs.add(html);
    });

    const $clone = load("<wrapper/>", { xmlMode: true });
    const $wrapper = $clone("wrapper");
    $wrapper.append($svg.html());
    $wrapper.find("defs").remove();

    if (!hasGraphics($wrapper)) {
      console.warn(
        `[sprite] Похоже, "${rel}" пустой после оптимизации. Проверь SVG.`,
      );
    }

    const inner = $wrapper.html() || "";
    const symbol = [
      `<symbol id="${id}"${viewBox ? ` viewBox="${viewBox}"` : ""} fill="none">`,
      inner,
      `</symbol>`,
    ].join("");

    symbols.push(symbol);
  }

  await fs.mkdir(OUT_DIR, { recursive: true });

  const sprite = [
    `<?xml version="1.0" encoding="UTF-8"?>`,
    `<!-- Generated by build-sprite.mjs -->`,
    `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"`,
    `     style="position:absolute; width:0; height:0; overflow:hidden;">`,
    `<defs>`,
    ...[...sharedDefs],
    ...symbols,
    `</defs>`,
    `</svg>`,
    ``,
  ].join("\n");

  await fs.writeFile(OUT_FILE, sprite, "utf8");
  console.log(
    `[sprite] OK: ${path.relative(CWD, OUT_FILE)} (icons: ${symbols.length})`,
  );
}

build().catch((e) => {
  console.error(e);
  process.exit(1);
});
